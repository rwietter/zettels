---
title: GraphQL
icon: vscode-icons:file-type-codekit
---

# GraphQL

> GraphQL √© uma linguagem de consulta para sua API e um tempo de execu√ß√£o do lado do servidor para executar consultas usando um sistema de tipos que voc√™ define para seus dados.¬†O GraphQL n√£o est√° vinculado a nenhum banco de dados ou mecanismo de armazenamento espec√≠fico e, em vez disso, √© apoiado por seu c√≥digo e dados existentes.
> 

---

### Arquitetura

A arquitetura do GraphQL √© em alto n√≠vel composta por **TypeDefs** e **Resolvers**. Os Typedefs definem a caracteristica dos dados e fun√ß√µes, ou seja, os tipos que os caracterizam desde a request a response. O servi√ßo primeiro verifica uma consulta para garantir que ela se refira apenas aos tipos e campos definidos e, em seguida, executa as fun√ß√µes fornecidas para produzir um resultado.

O GraphQL vem com um conjunto padr√£o de tipos, mas um servidor GraphQL tamb√©m pode declarar seus pr√≥prios tipos personalizados, desde que possam ser serializados em seu formato de transporte.

O¬†*tipo de opera√ß√£o*¬†√©¬†*query*,¬†*mutation*¬†ou¬†*subscription*¬†e descreve o tipo de opera√ß√£o que voc√™ pretende fazer.¬†O tipo de opera√ß√£o √© obrigat√≥rio, a menos que voc√™ esteja usando a sintaxe abreviada de consulta, caso em que voc√™ n√£o pode fornecer um nome ou defini√ß√µes de vari√°vel para sua opera√ß√£o.

---

### Typedefs

************Query:************

**Mutation:** 

**Subscription:** 

```graphql
const typeDefs = gql`
	# define o tipo do dado a ser manipulado
  type Todo {
    id: String
    title: String
    description: String
    completed: Boolean
  }

	# define a fun√ß√£o de busca e o retorno da fun√ß√£o -> Array de Todos
  type Query {
    getTodos: [Todo]
  }

	# define as fun√ß√µes e argumetos que ir√£o manipular um recurso
  type Mutation {
    addTodo(title: String!, description: String!, completed: Boolean!): [Todo]
    deleteTodo(id: String!): [Todo]
    updateTodo(id: String!, title: String, description: String, completed: Boolean): [Todo]
  }
`;
```

---

### Resolvers

```tsx
// Query
export const getTodos = (): Todos => {
    return todos
}

// Mutation
export const addTodo = (parent: any, args: Todo): Todos => {
  todos.push({
    id: randomUUID(),
    title: args.title,
    description: args.description,
    completed: args.completed,
  });
  return todos;
};
```

---

### Schema

```jsx
import * as mutation from '../resolvers/mutation'
import * as query from '../resolvers/query';

const resolvers = {
  Query: query,
  Mutation: mutation,
};

// build schema
const server = new ApolloServer(schema);

server.listen({ port: APOLLO_SERVER_PORT }).then(({ url }) => {
  console.log(`üöÄ  Server ready at ${url}`);
});
```

---

### Type system

- **Object types and fields**
    - `Character`√© um¬†*tipo de objeto GraphQL*¬†, o que significa que √© um tipo com alguns campos.¬†A maioria dos tipos em seu esquema ser√£o tipos de objeto.
    - Os atributos `name` e `appearsIn` s√£o campos do tipo `Character`
    - `String` √© um dos tipos escalares internos - esses s√£o tipos que resolvem para um √∫nico objeto escalar e n√£o podem ter subsele√ß√µes na consulta.
    - `String!` significa que o campo n√£o pode ser nulo.
    - `[Episode!]!` representa um array de `Episode`. Como tamb√©m √© **non-nullable**, voc√™ sempre pode esperar um array (com zero ou mais itens) ao consultar. E como `Episode!` tamb√©m √© **non-nullable**, voc√™ sempre pode esperar que cada item do array seja um `Episode`.
    
    ```graphql
    type Character {
      name: String!
      appearsIn: [Episode!]!
    }
    ```
    
- **Root Operation Types**
    - S√£o os tipos padr√µes de consulta de um recurso e altera√ß√£o de um recurso.
    
    ```graphql
    schema {
      query: Query
      mutation: Mutation
    }
    ```
    
- **Scalar types**
    - Um tipo de objeto GraphQL tem um nome e campos, mas em algum momento esses campos precisam resolver alguns dados concretos
    
    > `Int`: A signed 32‚Äêbit integer
    `Float`: A signed double-precision floating-point value.
    `String`: A UTF‚Äê8 character sequence.
    `Boolean`:¬†`true`¬†or¬†`false`.
    `ID`: O tipo escalar ID representa um identificador exclusivo, geralmente usado para buscar novamente um objeto ou como chave para um cache.¬†O tipo de ID √© serializado da mesma forma que uma String.
    > 
- **Personal Scalars**
    - Na maioria das implementa√ß√µes de servi√ßo GraphQL, tamb√©m h√° uma maneira de especificar tipos escalares personalizados.¬†Por exemplo, poder√≠amos definir um tipo¬†`Date`.
    
    ```graphql
    type Event {
      id: ID!
      date: Date!
    }
    
    ```
    
    ```tsx
    import { GraphQLScalarType, Kind } from 'graphql';
    
    const dateScalar = new GraphQLScalarType({
      name: 'Date',
      description: 'Date custom scalar type',
      serialize(value: Date) {
        return value.getTime(); // Convert outgoing Date to integer for JSON
      },
      parseValue(value: number) {
        return new Date(value); // Convert incoming integer to Date
      },
      parseLiteral(ast) {
        if (ast.kind === Kind.INT) {
          // Convert hard-coded AST string to integer and then to Date
          return new Date(parseInt(ast.value, 10));
        }
        // Invalid hard-coded value (not an integer)
        return null;
      },
    });
    ```
    
    ```jsx
    const resolvers = {
      Date: dateScalar,
    };
    ```
    
- **Enumeration types**
    - Tamb√©m chamados de¬†***Enums***¬†, os tipos de enumera√ß√£o s√£o um tipo especial de escalar restrito a um conjunto espec√≠fico de valores permitidos.¬†Isso permite que voc√™:
        1. Valide se qualquer argumento desse tipo √© um dos valores permitidos.
        2. Comunicar atrav√©s do sistema de tipos que um campo sempre ser√° um de um conjunto finito de valores.
    
    ```jsx
    /*  Isso significa que onde quer que usemos o tipo ***Episode*** em nosso esquema,
    		esperamos que seja exatamente um de **NEWHOPE**, EMPIRE ou JEDI.
    */
    enum Episode {
      NEWHOPE
      EMPIRE
      JEDI
    }
    ```
    
- **Lists and Non-Null**
    - Aqui, estamos usando um tipo¬†`String` e marcando-o como¬†*Non-Null*¬†adicionando um ponto de exclama√ß√£o¬†`!`ap√≥s o nome do tipo
    
    ```graphql
    type Character {
      name: String!
      appearsIn: [Episode]!
    }
    ```
    
    - Em listas adiciona-se o tipo do dado da lista entre colchetes e se os valores internos s√£o obrigat√≥rios n√£o-nulos e se o field retorna sempre uma lista n√£o nula com `!`
    
    ```graphql
    type Character {
      nonNull: [String!]!      # ['a', null, 'b'] -> error || ['a', 'b'] || [] -> OK
    	valueNull: [String]!     # null -> error | [] -> OK
    	listNull: [String!]      # ['a', null] -> error || [] -> OK
    	listValueNull: [String]  # ['a', 'b', null] || [] -> OK
    }
    ```
    
- **Interfaces**
    - Uma¬†***Interface***¬†√© um tipo abstrato que inclui um determinado conjunto de campos que um tipo deve incluir para implementar a interface.
    
    ```graphql
    interface Character {
      id: ID!
      name: String!
      friends: [Character]
      appearsIn: [Episode]!
    }
    ```
    
    - Isso significa que qualquer tipo que¬†*implemente* `Character`¬†precisa ter esses campos exatos, com esses argumentos e tipos de retorno.
    
    ```graphql
    type Human implements Character {
      id: ID!
      name: String!
      friends: [Character]
      appearsIn: [Episode]!
      starships: [Starship]
      totalCredits: Int
    }
    
    type Droid implements Character {
      id: ID!
      name: String!
      friends: [Character]
      appearsIn: [Episode]!
      primaryFunction: String
    }
    ```
    
    ```graphql
    # query
    query HeroForEpisode($ep: Episode!) {
      hero(episode: $ep) {
        name
        ... on Droid {
          primaryFunction
        }
        ... on Human {
          starships
    			totalCredits
        }
      }
    }
    ```
    
- **Union types**
    - Os tipos de uni√£o s√£o muito semelhantes √†s interfaces, mas n√£o especificam nenhum campo comum entre os tipos.
    
    ```graphql
    union SearchResult = Human | Droid | Starship
    ```
    
    - Sempre que retornamos um¬†`SearchResult` tipo em nosso esquema, podemos obter um¬†`Human`, um¬†`Droid`ou um¬†`Starship`.¬†Observe que os **membros de um tipo de uni√£o precisam ser tipos de objetos concretos**;¬†voc√™ n√£o pode criar um tipo de uni√£o a partir de interfaces ou outras uni√µes.
    
    ```graphql
    # Necess√°rio utilizar fragments
    {
      search(text: "an") {
        __typename
        ... on Human {
          name
          height
        }
        ... on Droid {
          name
          primaryFunction
        }
        ... on Starship {
          name
          length
        }
      }
    }
    ```
    
- **Input types**
    - Input types permitem criar e passar objetos complexo. Os input types s√£o exatamente iguais aos tipos de objetos regulares, mas com a palavra-chave¬†`input` em vez de¬†`type`
    - Os campos em um input type podem se referir a input types, mas voc√™ n√£o pode misturar input e output types em seu schema.
    - Os input types tamb√©m n√£o podem ter argumentos em seus campos.
    
    ```graphql
    input ReviewInput {
      stars: Int!
      commentary: String
    }
    ```
    
    ```graphql
    # mutation
    mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {
      createReview(episode: $ep, review: $review) {
        stars
        commentary
      }
    }
    
    # args
    {
      "ep": "JEDI",
      "review": {
        "stars": 5,
        "commentary": "This is a great movie!"
      }
    }
    
    ```
    

---

### Relacionamentos

> As consultas do GraphQL podem percorrer objetos relacionados e seus campos, permitindo que os clientes busquem muitos dados relacionados em uma solicita√ß√£o, em vez de fazer v√°rias viagens de ida e volta, como seria necess√°rio em uma arquitetura REST cl√°ssica.
> 

```graphql
# query
hero {
    name
    friends {
      name
    }
  }
}

# Generate
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "friends": [
        {
          "name": "Luke Skywalker"
        },
        {
          "name": "Han Solo"
        },
        {
          "name": "Leia Organa"
        }
      ]
    }
  }
}
```

---

### Argumentos

> Em um sistema como REST, voc√™ s√≥ pode passar um √∫nico conjunto de argumentos - os par√¢metros de consulta e os segmentos de URL em sua solicita√ß√£o. Mas no GraphQL, cada campo e objeto aninhado pode obter seu pr√≥prio conjunto de argumentos, tornando o GraphQL um substituto completo para fazer v√°rias buscas de API. Voc√™ pode at√© passar argumentos para campos escalares, para implementar transforma√ß√µes de dados uma vez no servidor, em vez de em cada cliente separadamente.
> 
- **Todos os argumentos s√£o nomeados.¬†Ao contr√°rio de linguagens como JavaScript e Python, onde as fun√ß√µes recebem uma lista de argumentos ordenados, todos os argumentos no GraphQL s√£o passados especificamente pelo nome.**
- **Os argumentos podem ser obrigat√≥rios ou opcionais.¬†Quando um argumento √© opcional, podemos definir um¬†*valor padr√£o.***

```graphql
# Query
{
  human(id: "1000") {
    name
    height(unit: FOOT)
    length(unit: LengthUnit = METER): Float
  }
}

# Produce
{
  "data": {
    "human": {
      "name": "Luke Skywalker",
      "height": 5.6430448
    }
  }
}
```

---

### Aliases

> Os campos do objeto de resultado correspondem ao nome do campo na consulta, mas n√£o incluem argumentos, voc√™ n√£o pode consultar diretamente o mesmo campo com argumentos diferentes. No exemplo abaixo, os dois¬†`hero`campos teriam entrado em conflito, mas como podemos alias a nomes diferentes, podemos obter os dois resultados em uma solicita√ß√£o.
> 

```graphql
# Query
{
  empireHero: hero(episode: EMPIRE) {
    name
  }
  jediHero: hero(episode: JEDI) {
    name
  }
}

# Produce
{
  "data": {
    "empireHero": {
      "name": "Luke Skywalker"
    },
    "jediHero": {
      "name": "R2-D2"
    }
  }
}
```

---

### **Vari√°veis**

- As defini√ß√µes de vari√°veis podem ser opcionais (`String`) ou obrigat√≥rias (`String!`). Se o campo para o qual voc√™ est√° passando a vari√°vel requer um argumento n√£o nulo, a vari√°vel tamb√©m deve ser obrigat√≥ria.
- As vari√°veis s√£o declaradas como argumento de fun√ß√£o `$variable` `Type!`
- Vari√°veis padr√£o (`$completed: Boolean = false`)

```graphql
mutation AddTodo($title: String! $description: String! $completed: Boolean = false) {
    addTodo(title: $title, description: $description, completed: $completed) {
      id
      title
      description
      completed
    }
  }
```

```tsx
const [addTodo] = useMutation(ADD_TODO, { update: updateTodoCache });
addTodo({ variables: { title, description, completed: false } });
```

---

### **Directives**

> `@include`: por exemplo, podemos imaginar um componente de UI que possui uma vis√£o resumida e detalhada, onde um inclui mais campos que o outro.

‚Ä¢ `@include(if: Boolean)`Apenas inclua este campo no resultado se o argumento for¬†`true`.
‚Ä¢ `@skip(if: Boolean)`Ignore este campo se o argumento for¬†`true`.
> 

```graphql
query Hero($episode: Episode, $withFriends: Boolean!) {
  hero(episode: $episode) {
    name
    friends @include(if: $withFriends) {
      name
    }
  }
}

```

```graphql
# Variables with directive false
{
  "episode": "JEDI",
  "withFriends": false
}

# Produces this
{
  "data": {
    "hero": { "name": "R2-D2" }
  }
}
```

```graphql
# Variables with directive true
{
  "episode": "JEDI",
  "withFriends": true
}

# Produces this
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "friends": [
        { "name": "Luke Skywalker" },
        { "name": "Han Solo" },
        { "name": "Leia Organa" }
      ]
    }
  }
}
```

---

### Mutation

- Enquanto os campos de **consulta s√£o executados em paralelo**, os **campos de muta√ß√£o s√£o executados em s√©rie**, um ap√≥s o outro. Isso significa que, se enviarmos duas¬†`incrementCredits`muta√ß√µes em uma solicita√ß√£o, a primeira ter√° a garantia de terminar antes que a segunda comece.
- 

---

### **Inline Fragments**

- Se voc√™ estiver consultando um campo que retorna uma interface ou um tipo de uni√£o, precisar√° usar¬†*fragmentos embutidos*¬†para acessar dados no tipo concreto subjacente.

```graphql
# interface
interface Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
}

# types
type Human implements Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
  starships: [Starship]
  totalCredits: Int
}

type Droid implements Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
  primaryFunction: String
}

# Object type
type hero {
	episode: [Droid]
}
```

```graphql
# query
query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}

# args
{
  "ep": "JEDI"
}
```

---

### **Metacampos**

- Dado que existem algumas situa√ß√µes em que voc√™ n√£o sabe que tipo voc√™ receber√° de volta do servi√ßo GraphQL, voc√™ precisa determinar como lidar com esses dados no cliente.¬†O GraphQL permite que voc√™ solicite¬†`__typename`, um metacampo, em qualquer ponto de uma consulta para obter o nome do tipo de objeto naquele ponto.

```graphql
{
  search(text: "an") {
    __typename
    ... on Human {
      name
    }
    ... on Droid {
      name
    }
    ... on Starship {
      name
    }
  }
}
```

---

### Validation
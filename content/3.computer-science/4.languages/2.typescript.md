---
title: Typescript
description: Typescript
icon: vscode-icons:file-type-codekit
---

# Typescript

### Generics 

The idea of generics is to allow a type or function to operate on a variety of types while providing compile-time type safety. This is done by capturing the type of the argument(s) to a function and then using that captured type when defining the function’s return type.

```ts
function identity<T>(arg: T): T {
  return arg;
}

/*
  <T>: Type
  <K>: Key
  <V>: Value
  <E>: Element
*/
```

### Type Guards

Type guards are some expression that performs a runtime check that guarantees the type in some scope. Type guards are used to narrow down the type in the code flow.

```ts
function isString(x: any): x is string {
  return typeof x === 'string';
}
```

### Type Inference

Type inference is the ability of the compiler to automatically determine the type of an expression. Type inference is mainly used for local variables and parameters.

```ts
let x = 3; // x has type number
```

### Type Aliases

Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
```

### Interfaces

Interfaces are structural, anything that has the properties is compliant with the interface. Unlike type aliases, interfaces create a new name that is used everywhere. Type aliases don’t create a new name – for instance, error messages won’t use the alias name.

```ts
interface Point {
  x: number;
  y: number;
}
```

### Classes

Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in TypeScript support public, private, and protected modifiers. Public by default.

```ts
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  greet() {
    return 'Hello, ' + this.greeting;
  }
}
```

### Enums

Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.

```ts
enum Color {
  Red,
  Green,
  Blue,
}
```

### Decorators

Decorators are a feature that allows adding annotations to classes, methods, properties, and parameters. Decorators are a stage 2 proposal for JavaScript and are available as an experimental feature of TypeScript.

```ts
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}
```

### Modules

Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. 

```ts
export class ZipCodeValidator implements StringValidator {
  isAcceptable(s: string) {
    return s.length === 5 && numberRegexp.test(s);
  }
}
```

### Namespaces

Namespaces are a way to organize code. They are a way to group related functionality and to provide a way to handle name collisions. 

```ts
namespace Validation {
  export interface StringValidator {
    isAcceptable(s: string): boolean;
  }
}
```

### Mixins

A mixin is a class that contains methods for other classes without having to be the parent class of those classes. A mixin class contains methods and properties, and can be implemented by other classes without having to be the parent class of those classes.

```ts
function applyMixins(derivedCtor: any, baseCtors: any[]) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      derivedCtor.prototype[name] = baseCtor.prototype[name];
    });
  });
}
```

---

### Docs
- [Typescript Type-level](https://type-level-typescript.com/)